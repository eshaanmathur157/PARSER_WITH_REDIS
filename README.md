OK, SO WE USE:
REDIS_RECEIVER -> IT HAS THE PARSER THAT CONNECTS TO THE MAIN HTTP SERVER AND ALSO DOES PARSING --> REAL TIME POOL UPDATES -> parser_linux
COMPILATION COMMAND FOR THE PARSER: 
g++ -O3 -march=native -mavx2 -mpclmul  parser_main.cpp file_utils.cpp arrow_utils.cpp stage2_processing2.cpp stage1_simd.cpp   -o parser_linux -larrow_flight -lredis++ -lhiredis -pthread    -larrow -lxxhash -lpthread -lrt

SERVER -> IT HAS THE FLIGHT SERVER, INFERENCE, INGEST PRICES, COMBINED SUBSCRIBER.
python flightServerWithRW.py

python inference2.py --> ASYNC MODEL RUNNING

python ingest_prices.py

python combined_subscriber.py <worker_id>

SQL QUERIES FOR RISING WAVE:
CREATE MATERIALIZED VIEW pool_master_5min AS SELECT b.time, b.poolIdentifierBaseVault AS poolIdentifier, b.number_of_buys, b.number_of_sells, b.number_of_unique_buyers, b.number_of_unique_sellers, b.buy_sell_ratio, b.buy_perc, b.sell_perc, a.price_delta, a.price_std, a.buy_price_std, a.sell_price_std, a.price_max, a.price_min, a.aggregated_buy_volume_usd, a.aggregated_sell_volume_usd, a.total_volume_usd, a.max_liquidity, a.min_liquidity FROM pool_buys b JOIN pool_analytics_5min a ON b.time = a.time AND b.poolIdentifierBaseVault = a.poolIdentifier;

CREATE MATERIALIZED VIEW pool_analytics_5min AS WITH clean_b AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE base_vault IS NOT NULL), clean_q AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE quote_vault IS NOT NULL), pair_trades AS (SELECT (b.timestamp / 300) * 300 AS time, b.base_vault as poolIdentifier, b.timestamp as exact_ts, ABS(b.post_balance - b.pre_balance) as delta_base, ABS(q.post_balance - q.pre_balance) as delta_quote, COALESCE(NULLIF(b.base_price, 'NaN'::DOUBLE PRECISION), 0) as safe_base_price, COALESCE(NULLIF(q.quote_price, 'NaN'::DOUBLE PRECISION), 0) as safe_quote_price, b.post_balance as base_bal, q.post_balance as quote_bal, CASE WHEN b.pre_balance > b.post_balance AND q.pre_balance < q.post_balance THEN 'BUY' WHEN b.pre_balance < b.post_balance AND q.pre_balance > q.post_balance THEN 'SELL' ELSE 'OTHER' END as trade_type FROM clean_b b JOIN clean_q q ON b.signature = q.signature AND b.timestamp = q.timestamp), calculated_trades AS (SELECT time, exact_ts, poolIdentifier, trade_type, (delta_quote / NULLIF(delta_base, 0)) as exec_price, CASE WHEN trade_type IN ('BUY', 'SELL') THEN (delta_quote * safe_quote_price) ELSE 0 END as vol_usd, ((base_bal * safe_base_price) + (quote_bal * safe_quote_price)) as liquidity_usd FROM pair_trades) SELECT time, poolIdentifier, (last_value(exec_price ORDER BY exact_ts) - first_value(exec_price ORDER BY exact_ts)) as price_delta, STDDEV_SAMP(exec_price) as price_std, STDDEV_SAMP(CASE WHEN trade_type = 'BUY' THEN exec_price END) as buy_price_std, STDDEV_SAMP(CASE WHEN trade_type = 'SELL' THEN exec_price END) as sell_price_std, MAX(exec_price) as price_max, MIN(exec_price) as price_min, SUM(CASE WHEN trade_type = 'BUY' THEN vol_usd ELSE 0 END) as aggregated_buy_volume_usd, SUM(CASE WHEN trade_type = 'SELL' THEN vol_usd ELSE 0 END) as aggregated_sell_volume_usd, SUM(vol_usd) as total_volume_usd, MAX(liquidity_usd) as max_liquidity, MIN(liquidity_usd) as min_liquidity FROM calculated_trades GROUP BY poolIdentifier, time;

CREATE MATERIALIZED VIEW pool_buys AS WITH clean_b AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE base_vault IS NOT NULL), clean_q AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE quote_vault IS NOT NULL), clean_u AS (SELECT * FROM transactions WHERE base_vault IS NULL AND quote_vault IS NULL), raw_joins AS (SELECT (b.timestamp / 300) * 300 AS time, b.base_vault AS poolIdentifierBaseVault, b.signature, b.pre_balance as b_pre, b.post_balance as b_post, b.mint as b_mint, q.pre_balance as q_pre, q.post_balance as q_post, u.pre_balance as u_pre, u.post_balance as u_post, u.wallet as u_wallet, u.mint as u_mint FROM clean_b b JOIN clean_q q ON b.signature = q.signature JOIN clean_u u ON b.signature = u.signature), daily_counts AS (SELECT time, poolIdentifierBaseVault, COUNT(DISTINCT CASE WHEN b_pre > b_post AND q_pre < q_post THEN signature END) AS num_buys, COUNT(DISTINCT CASE WHEN b_pre < b_post AND q_pre > q_post THEN signature END) AS num_sells, COUNT(DISTINCT CASE WHEN (b_pre > b_post AND q_pre < q_post) AND u_mint = b_mint AND u_post > u_pre THEN signature END) AS num_unique_buyers, COUNT(DISTINCT CASE WHEN (b_pre < b_post AND q_pre > q_post) AND u_mint = b_mint AND u_pre > u_post THEN signature END) AS num_unique_sellers FROM raw_joins GROUP BY time, poolIdentifierBaseVault) SELECT time, poolIdentifierBaseVault, num_buys AS number_of_buys, num_sells AS number_of_sells, num_unique_buyers AS number_of_unique_buyers, num_unique_sellers AS number_of_unique_sellers, ROUND(num_buys::NUMERIC / NULLIF(num_sells, 0), 2) AS buy_sell_ratio, ROUND((num_buys::NUMERIC / NULLIF(num_buys + num_sells, 0)) * 100, 2) AS buy_perc, ROUND((num_sells::NUMERIC / NULLIF(num_buys + num_sells, 0)) * 100, 2) AS sell_perc FROM daily_counts;
