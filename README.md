OK, SO WE USE:
REDIS_RECEIVER -> IT HAS THE PARSER THAT CONNECTS TO THE MAIN HTTP SERVER AND ALSO DOES PARSING --> REAL TIME POOL UPDATES -> parser_linux
COMPILATION COMMAND FOR THE PARSER: 
g++ -O3 -march=native -mavx2 -mpclmul  parser_main.cpp file_utils.cpp arrow_utils.cpp stage2_processing2.cpp stage1_simd.cpp   -o parser_linux -larrow_flight -lredis++ -lhiredis -pthread    -larrow -lxxhash -lpthread -lrt

SERVER -> IT HAS THE FLIGHT SERVER, INFERENCE, INGEST PRICES, COMBINED SUBSCRIBER.
python flightServerWithRW.py

python inference2.py --> ASYNC MODEL RUNNING 

python ingest_prices.py

python combined_subscriber.py <worker_id>

SQL QUERIES FOR RISING WAVE:
CREATE MATERIALIZED VIEW pool_master_5min AS SELECT b.time, b.poolIdentifierBaseVault AS poolIdentifier, b.number_of_buys, b.number_of_sells, b.number_of_unique_buyers, b.number_of_unique_sellers, b.buy_sell_ratio, b.buy_perc, b.sell_perc, a.price_delta, a.price_std, a.buy_price_std, a.sell_price_std, a.price_max, a.price_min, a.aggregated_buy_volume_usd, a.aggregated_sell_volume_usd, a.total_volume_usd, a.max_liquidity, a.min_liquidity FROM pool_buys b JOIN pool_analytics_5min a ON b.time = a.time AND b.poolIdentifierBaseVault = a.poolIdentifier;

CREATE MATERIALIZED VIEW pool_analytics_5min AS WITH clean_b AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE base_vault IS NOT NULL), clean_q AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE quote_vault IS NOT NULL), pair_trades AS (SELECT (b.timestamp / 300) * 300 AS time, b.base_vault as poolIdentifier, b.timestamp as exact_ts, ABS(b.post_balance - b.pre_balance) as delta_base, ABS(q.post_balance - q.pre_balance) as delta_quote, COALESCE(NULLIF(b.base_price, 'NaN'::DOUBLE PRECISION), 0) as safe_base_price, COALESCE(NULLIF(q.quote_price, 'NaN'::DOUBLE PRECISION), 0) as safe_quote_price, b.post_balance as base_bal, q.post_balance as quote_bal, CASE WHEN b.pre_balance > b.post_balance AND q.pre_balance < q.post_balance THEN 'BUY' WHEN b.pre_balance < b.post_balance AND q.pre_balance > q.post_balance THEN 'SELL' ELSE 'OTHER' END as trade_type FROM clean_b b JOIN clean_q q ON b.signature = q.signature AND b.timestamp = q.timestamp), calculated_trades AS (SELECT time, exact_ts, poolIdentifier, trade_type, (delta_quote / NULLIF(delta_base, 0)) as exec_price, CASE WHEN trade_type IN ('BUY', 'SELL') THEN (delta_quote * safe_quote_price) ELSE 0 END as vol_usd, ((base_bal * safe_base_price) + (quote_bal * safe_quote_price)) as liquidity_usd FROM pair_trades) SELECT time, poolIdentifier, (last_value(exec_price ORDER BY exact_ts) - first_value(exec_price ORDER BY exact_ts)) as price_delta, STDDEV_SAMP(exec_price) as price_std, STDDEV_SAMP(CASE WHEN trade_type = 'BUY' THEN exec_price END) as buy_price_std, STDDEV_SAMP(CASE WHEN trade_type = 'SELL' THEN exec_price END) as sell_price_std, MAX(exec_price) as price_max, MIN(exec_price) as price_min, SUM(CASE WHEN trade_type = 'BUY' THEN vol_usd ELSE 0 END) as aggregated_buy_volume_usd, SUM(CASE WHEN trade_type = 'SELL' THEN vol_usd ELSE 0 END) as aggregated_sell_volume_usd, SUM(vol_usd) as total_volume_usd, MAX(liquidity_usd) as max_liquidity, MIN(liquidity_usd) as min_liquidity FROM calculated_trades GROUP BY poolIdentifier, time;

CREATE MATERIALIZED VIEW pool_buys AS WITH clean_b AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE base_vault IS NOT NULL), clean_q AS (SELECT DISTINCT ON (signature) * FROM transactions WHERE quote_vault IS NOT NULL), clean_u AS (SELECT * FROM transactions WHERE base_vault IS NULL AND quote_vault IS NULL), raw_joins AS (SELECT (b.timestamp / 300) * 300 AS time, b.base_vault AS poolIdentifierBaseVault, b.signature, b.pre_balance as b_pre, b.post_balance as b_post, b.mint as b_mint, q.pre_balance as q_pre, q.post_balance as q_post, u.pre_balance as u_pre, u.post_balance as u_post, u.wallet as u_wallet, u.mint as u_mint FROM clean_b b JOIN clean_q q ON b.signature = q.signature JOIN clean_u u ON b.signature = u.signature), daily_counts AS (SELECT time, poolIdentifierBaseVault, COUNT(DISTINCT CASE WHEN b_pre > b_post AND q_pre < q_post THEN signature END) AS num_buys, COUNT(DISTINCT CASE WHEN b_pre < b_post AND q_pre > q_post THEN signature END) AS num_sells, COUNT(DISTINCT CASE WHEN (b_pre > b_post AND q_pre < q_post) AND u_mint = b_mint AND u_post > u_pre THEN signature END) AS num_unique_buyers, COUNT(DISTINCT CASE WHEN (b_pre < b_post AND q_pre > q_post) AND u_mint = b_mint AND u_pre > u_post THEN signature END) AS num_unique_sellers FROM raw_joins GROUP BY time, poolIdentifierBaseVault) SELECT time, poolIdentifierBaseVault, num_buys AS number_of_buys, num_sells AS number_of_sells, num_unique_buyers AS number_of_unique_buyers, num_unique_sellers AS number_of_unique_sellers, ROUND(num_buys::NUMERIC / NULLIF(num_sells, 0), 2) AS buy_sell_ratio, ROUND((num_buys::NUMERIC / NULLIF(num_buys + num_sells, 0)) * 100, 2) AS buy_perc, ROUND((num_sells::NUMERIC / NULLIF(num_buys + num_sells, 0)) * 100, 2) AS sell_perc FROM daily_counts;



NEW SET OF QUERES ARE BELOW WHERE WE CHANGED THE UNIQUE BUYERS AND UNIQUE SELLERS:

CREATE MATERIALIZED VIEW pool_buys AS WITH trade_counts AS (SELECT (floor(T.timestamp / 300) * 300)::bigint AS bucket_start, Z.wallet AS base_vault, count(CASE WHEN Z.pre_balance > Z.post_balance AND T.pre_balance < T.post_balance THEN 1 END) AS no_of_buys, count(CASE WHEN Z.pre_balance < Z.post_balance AND T.pre_balance > T.post_balance THEN 1 END) AS no_of_sells, count(DISTINCT CASE WHEN Z.pre_balance > Z.post_balance AND T.pre_balance < T.post_balance THEN T.signer END) AS unique_buyers, count(DISTINCT CASE WHEN Z.pre_balance < Z.post_balance AND T.pre_balance > T.post_balance THEN T.signer END) AS unique_sellers FROM (SELECT signature, timestamp, signer, wallet, pre_balance, post_balance, quote_vault FROM transactions WHERE wallet = quote_vault) T JOIN (SELECT signature, wallet, pre_balance, post_balance, base_vault FROM transactions WHERE wallet = base_vault) Z ON T.signature = Z.signature GROUP BY (floor(T.timestamp / 300) * 300), Z.wallet) SELECT bucket_start as timestamp, base_vault as poolIdentifier, no_of_buys as number_of_buys, no_of_sells as number_of_sells, unique_buyers as number_of_unique_buyers, unique_sellers as number_of_unique_sellers, CASE WHEN (no_of_buys + no_of_sells) = 0 THEN 0 ELSE ROUND((no_of_buys::numeric / (no_of_buys + no_of_sells)) * 100, 2) END AS buy_perc, CASE WHEN (no_of_buys + no_of_sells) = 0 THEN 0 ELSE ROUND((no_of_sells::numeric / (no_of_buys + no_of_sells)) * 100, 2) END AS sell_perc FROM trade_counts;



CREATE MATERIALIZED VIEW pool_analytics_5min AS WITH pair_trades AS (SELECT (floor(b.timestamp / 300) * 300)::bigint AS bucket_start, b.wallet as poolIdentifier, b.timestamp as exact_ts, CASE WHEN ABS(b.post_balance - b.pre_balance) = 0 THEN 0 ELSE ABS(q.post_balance - q.pre_balance) / ABS(b.post_balance - b.pre_balance) END as exec_price, CASE WHEN b.pre_balance > b.post_balance AND q.pre_balance < q.post_balance THEN 'BUY' WHEN b.pre_balance < b.post_balance AND q.pre_balance > q.post_balance THEN 'SELL' ELSE 'OTHER' END as trade_type, (ABS(q.post_balance - q.pre_balance) * CASE WHEN q.quote_price = 'NaN' THEN 0 ELSE COALESCE(q.quote_price, 0) END) as vol_usd, CASE WHEN b.base_price = 'NaN' OR q.quote_price = 'NaN' THEN NULL ELSE ((b.post_balance * COALESCE(b.base_price, 0)) + (q.post_balance * COALESCE(q.quote_price, 0))) END as liquidity_usd FROM (SELECT signature, timestamp, wallet, pre_balance, post_balance, base_price, quote_vault, base_vault FROM transactions WHERE wallet = base_vault) b JOIN (SELECT signature, timestamp, wallet, pre_balance, post_balance, quote_price FROM transactions WHERE wallet = quote_vault) q ON b.signature = q.signature), agg_stats AS (SELECT bucket_start as time, poolIdentifier, MAX(exec_price) as price_max, MIN(exec_price) as price_min, STDDEV_SAMP(exec_price) as price_std, SUM(CASE WHEN trade_type = 'BUY' THEN vol_usd ELSE 0 END) as aggregated_buy_volume_usd, SUM(CASE WHEN trade_type = 'SELL' THEN vol_usd ELSE 0 END) as aggregated_sell_volume_usd, SUM(vol_usd) as total_volume_usd, MAX(liquidity_usd) as max_liquidity, MIN(liquidity_usd) as min_liquidity, (ARRAY_AGG(exec_price ORDER BY exact_ts DESC))[1] as close_price, (ARRAY_AGG(exec_price ORDER BY exact_ts ASC))[1] as open_price FROM pair_trades GROUP BY bucket_start, poolIdentifier) SELECT time, poolIdentifier, (close_price - open_price) as price_delta, price_std, price_max, price_min, aggregated_buy_volume_usd, aggregated_sell_volume_usd, total_volume_usd, max_liquidity, min_liquidity FROM agg_stats;


CREATE MATERIALIZED VIEW pool_master_5min AS SELECT a.time, a.poolIdentifier, b.number_of_buys, b.number_of_sells, b.number_of_unique_buyers, b.number_of_unique_sellers, CASE WHEN b.number_of_sells = 0 THEN 0 ELSE ROUND(b.number_of_buys::numeric / b.number_of_sells, 2) END as buy_sell_ratio, b.buy_perc, b.sell_perc, a.price_delta, a.price_std, a.price_max, a.price_min, a.aggregated_buy_volume_usd, a.aggregated_sell_volume_usd, a.total_volume_usd, a.max_liquidity, a.min_liquidity FROM pool_buys b JOIN pool_analytics_5min a ON b.timestamp = a.time AND b.poolIdentifier = a.poolIdentifier;

pool buys is same just the following are added:
CREATE MATERIALIZED VIEW pool_analytics_5min AS SELECT Z.base_vault AS poolIdentifier, (floor(Z.timestamp / 300) * 300)::bigint AS interval_unix, SUM(CASE WHEN Z.pre_balance > Z.post_balance AND T.pre_balance < T.post_balance THEN (Z.pre_balance - Z.post_balance) * Z.base_price ELSE 0 END) AS aggregated_buy_volume, SUM(CASE WHEN Z.pre_balance < Z.post_balance AND T.pre_balance > T.post_balance THEN (Z.post_balance - Z.pre_balance) * Z.base_price ELSE 0 END) AS aggregated_sell_volume, SUM(CASE WHEN Z.pre_balance > Z.post_balance AND T.pre_balance < T.post_balance THEN (Z.pre_balance - Z.post_balance) * Z.base_price WHEN Z.pre_balance < Z.post_balance AND T.pre_balance > T.post_balance THEN (Z.post_balance - Z.pre_balance) * Z.base_price ELSE 0 END) AS total_volume, MIN(Z.base_price) AS price_min, MAX(Z.base_price) AS price_max, COALESCE(stddev_samp(Z.base_price), 0) AS price_std, MIN((Z.post_balance * Z.base_price) + (T.post_balance * T.quote_price)) AS min_liquidity, MAX((Z.post_balance * Z.base_price) + (T.post_balance * T.quote_price)) AS max_liquidity FROM (SELECT signature, timestamp, base_vault, pre_balance, post_balance, base_price FROM transactions WHERE wallet = base_vault) Z JOIN (SELECT signature, quote_vault, pre_balance, post_balance, quote_price FROM transactions WHERE wallet = quote_vault) T ON Z.signature = T.signature WHERE Z.base_price != 'NaN' AND T.quote_price != 'NaN' GROUP BY Z.base_vault, floor(Z.timestamp / 300) * 300 ORDER BY interval_unix DESC, poolIdentifier;



CREATE MATERIALIZED VIEW pool_features_5min AS WITH combined_stats AS (SELECT Z.base_vault AS poolIdentifier, (floor(Z.timestamp / 300) * 300)::bigint AS interval_unix, Z.base_price, ((Z.post_balance * Z.base_price) + (T.post_balance * T.quote_price)) AS liquidity_val, CASE WHEN Z.pre_balance > Z.post_balance AND T.pre_balance < T.post_balance THEN 1 ELSE 0 END AS is_buy, CASE WHEN Z.pre_balance < Z.post_balance AND T.pre_balance > T.post_balance THEN 1 ELSE 0 END AS is_sell, CASE WHEN Z.pre_balance > Z.post_balance AND T.pre_balance < T.post_balance THEN (Z.pre_balance - Z.post_balance) * Z.base_price ELSE 0 END AS buy_vol_usd, CASE WHEN Z.pre_balance < Z.post_balance AND T.pre_balance > T.post_balance THEN (Z.post_balance - Z.pre_balance) * Z.base_price ELSE 0 END AS sell_vol_usd, T.signer FROM (SELECT signature, timestamp, base_vault, pre_balance, post_balance, base_price FROM transactions WHERE wallet = base_vault) Z JOIN (SELECT signature, quote_vault, pre_balance, post_balance, quote_price, signer FROM transactions WHERE wallet = quote_vault) T ON Z.signature = T.signature WHERE Z.base_price != 'NaN' AND T.quote_price != 'NaN'), aggregated AS (SELECT poolIdentifier, interval_unix, COALESCE(stddev_samp(base_price), 0) AS price_std, SUM(buy_vol_usd) AS aggregated_buy_volume_usd, SUM(sell_vol_usd) AS aggregated_sell_volume_usd, SUM(buy_vol_usd + sell_vol_usd) AS total_volume_usd, MAX(liquidity_val) AS max_liquidity, MIN(liquidity_val) AS min_liquidity, SUM(is_buy) AS number_of_buys, SUM(is_sell) AS number_of_sells, COUNT(DISTINCT CASE WHEN is_buy = 1 THEN signer END) AS unique_buyers, COUNT(DISTINCT CASE WHEN is_sell = 1 THEN signer END) AS unique_sellers, MAX(base_price) AS price_max, MIN(base_price) AS price_min FROM combined_stats GROUP BY poolIdentifier, interval_unix) SELECT interval_unix, poolIdentifier, price_std, aggregated_buy_volume_usd, aggregated_sell_volume_usd, total_volume_usd, max_liquidity, min_liquidity, number_of_buys, number_of_sells, unique_buyers, unique_sellers, CASE WHEN (number_of_buys + number_of_sells) = 0 THEN 0 ELSE ROUND((number_of_buys::numeric / (number_of_buys + number_of_sells)) * 100, 2) END AS buy_perc, CASE WHEN (number_of_buys + number_of_sells) = 0 THEN 0 ELSE ROUND((number_of_sells::numeric / (number_of_buys + number_of_sells)) * 100, 2) END AS sell_perc, price_max, price_min FROM aggregated ORDER BY interval_unix DESC, poolIdentifier;
